/*
146. LRU Cache

Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
The functions get and put must each run in O(1) average time complexity.

 

Example 1:

Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
 

Constraints:

1 <= capacity <= 3000
0 <= key <= 104
0 <= value <= 105
At most 2 * 105 calls will be made to get and put.*/

class LRUCache {
public:
    struct ListNode                          //structure of double lnked list
    {
        int val=0;                          //stores key,value and pointers to next and previous node
        int key=0;
        ListNode* next=nullptr;
        ListNode* prev=nullptr;
    };

    int sz=0;                                //stores capacity of cache
    ListNode* head;                          //stores head and tail nodes od linked list
    ListNode* tail;
    unordered_map<int,ListNode*> keys;        //maps keys to nodes

    LRUCache(int capacity) 
    {  
                                              //we initialize sz to capacity and create head and tail nodes as well and link them also to establish the list
        sz=capacity;
        head=new ListNode();
        tail=new ListNode();
        head->key=INT_MAX;head->val=INT_MAX;
        tail->key=INT_MAX;tail->val=INT_MAX;
        head->next=tail;
        tail->prev=head;
    }
    
    int get(int key) {
        if(keys.find(key)==keys.end()) return -1;        //if node not present,return -1, else move down

        auto node=keys[key];                      //node corresponding to that key and value
            auto a=node->prev,b=node->next;      //we grab previous and next nodes of the node and link both next to each other
            a->next=b;b->prev=a;

            a=head,b=head->next;                //we take the node to beginning of cache by placing it between head node and the node next to it
            a->next=node;node->prev=a;
            b->prev=node;node->next=b;

        return node->val;                        //finally we return value of node
    }
    
    void put(int key, int value) {
        if(keys.find(key)==keys.end())                //node not present,so needs to be created
        {
            keys[key]=new ListNode();                //node creation
            keys[key]->key=key;
            keys[key]->val=value;

            auto h=head,t=head->next;                  //we place the node at beginning of the list between head node and the next node of head node
            t->prev=keys[key];keys[key]->next=t;
            h->next=keys[key];keys[key]->prev=h;

            if(keys.size()>sz)                        //if total size of nodes exceeds capacity,we unlink the node before tail node and delete it.froom the memory and from map as well
            {
                auto t=tail;
                auto x=tail->prev->prev;
                auto d=tail->prev;

                x->next=t;
                t->prev=x;
                
                keys.erase(d->key);
                delete d;
            }
        }
        else
        {                                            //here node is present,so we just change its position to beginning of list
            auto node=keys[key];
            node->val=value;                            //and change its value as well
            auto a=node->prev,b=node->next;
            a->next=b;b->prev=a;

            a=head,b=head->next;
            a->next=node;node->prev=a;
            b->prev=node;node->next=b;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
