/*
Islands and Treasure
Solved 
You are given a 
m
×
n
m×n 2D grid initialized with these three possible values:

-1 - A water cell that can not be traversed.
0 - A treasure chest.
INF - A land cell that can be traversed. We use the integer 2^31 - 1 = 2147483647 to represent INF.
Fill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest then the value should remain INF.

Assume the grid can only be traversed up, down, left, or right.

Modify the grid in-place.

Example 1:

Input: [
  [2147483647,-1,0,2147483647],
  [2147483647,2147483647,2147483647,-1],
  [2147483647,-1,2147483647,-1],
  [0,-1,2147483647,2147483647]
]

Output: [
  [3,-1,0,1],
  [2,2,1,-1],
  [1,-1,2,-1],
  [0,-1,3,4]
]
Example 2:

Input: [
  [0,-1],
  [2147483647,2147483647]
]

Output: [
  [0,-1],
  [1,2]
]
Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 100
grid[i][j] is one of {-1, 0, 2147483647}
*/

class Solution {
public:
    void islandsAndTreasure(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();                              //stores dimensions of grid

        vector<vector<bool>> visited(m,vector<bool> (n,false));          //marks which squares we have visited
        queue<pair<int,pair<int,int>>> q;                              //for BFS.it holds distance from treasures along with x and y co-ordinates
        for(int i=0;i<m;i++)                                                //we push treasure check coordinates into queue with distance as 0
        for(int j=0;j<n;j++)
        if(grid[i][j]==0)
        q.push({0,{i,j}});

        while(!q.empty())
        {  
            auto x=q.front();                                            //we pop a coordinate
            q.pop();

            int d=x.first,i=x.second.first,j=x.second.second;
            if(visited[i][j]||grid[i][j]==-1)continue;                  //if we have visited it or if it is a water well,we go to next iteration

            visited[i][j]=true;                                          //mark that we have visited it and change distance to treasure chest as minimum distance
            grid[i][j]=min(grid[i][j],d);

            if(i-1>=0)                                //we push nearby squares onto queue with distance=d+1
            q.push({d+1,{i-1,j}});
            if(i+1<m)
            q.push({d+1,{i+1,j}});
            if(j-1>=0)
            q.push({d+1,{i,j-1}});
            if(j+1<n)
            q.push({d+1,{i,j+1}});
        }
    }
};
