/*
57. Insert Interval

You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.

Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return intervals after the insertion.

Note that you don't need to modify intervals in-place. You can make a new array and return it.

 

Example 1:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Example 2:

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
 

Constraints:

0 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 105
intervals is sorted by starti in ascending order.
newInterval.length == 2
0 <= start <= end <= 105


*/


class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) 
    {
        if(intervals.size()==0)             //intervals is empty,so return newInterval within a vector
        return {newInterval};
        
        else if(newInterval[0]<intervals[0][0] && newInterval[1]<intervals[0][0])   //newInterval should be inserted before 1st interval
        {
            intervals.insert(intervals.begin(),newInterval);
            return intervals;
        }
        else if(newInterval[0]>intervals.back()[1])         //newInterval should be insert after last interval
        {
            intervals.push_back(newInterval);
            return intervals;
        }
        else
        {

            for(int i=1;i<intervals.size();i++)     //this case is executed if the newInterval falls between 2 intervals.The new Interval is inserted at that position and intervals is returned
            {    if(newInterval[0]<intervals[i][0]&&newInterval[1]<intervals[i][0]&&newInterval[0]>intervals[i-1][1])
                {
                    intervals.insert(intervals.begin()+i,newInterval);
                    return intervals;
                }
            }

            
            //this case is the worst case where we need to merge intervals
                vector<vector<int>> ans;                //new ans vector to be returned

                int start=INT_MAX,end=INT_MAX;          //denotes the indexes between which merging needs to be done

                for(int i=0;i<intervals.size();i++)
                {
                    //here start of new interval falls between intervals
                    if((i==0 && newInterval[0]<intervals[i][0])||(i>0&&newInterval[0]>intervals[i-1][1] &&newInterval[0]<intervals[i][0]))
                    {
                        start=i;
                    
                        break;
                    }
                    //here start of new interval falls within an interval
                    if(newInterval[0]>=intervals[i][0] && newInterval[0]<=intervals[i][1])
                    {
                        start=i;break;
                    }
                }

                for(int i=0;i<start;i++)            //we insert all intervals upto start inside ans
                    ans.push_back(intervals[i]);

                int a,b;                                    //stores upper bound and lower bound of merged interval

                for(int i=start;i<intervals.size();i++)
                {
                    a=min(newInterval[0],intervals[start][0]);          //stores lower bound of interval at start index and new interval

                    if(newInterval[1]<=intervals[i][1])                 //means upper bound is upper bound of intervals[i]
                    {
                        b=intervals[i][1];end=i+1;break;
                    }
                    else if(newInterval[1]>intervals[i][1]&&i+1<intervals.size()&&newInterval[1]<intervals[i+1][0]) //means upper bound is upper bound of new Interval
                    {
                        b=newInterval[1];end=i+1;break;
                    }
                    else if(newInterval[1]>intervals[i][1]&&i+1==intervals.size())      //means upper bound is upper bound of new Interval
                    {
                        b=newInterval[1];end=i+1;break;
                    }
                    else continue;          //means next interval isto be considered for above operations
                }


                ans.push_back({a,b});           //merging is done 

                for(int i=end;i<intervals.size();i++)           //intervals from end index are inserted as they are.
                    ans.push_back(intervals[i]);

                return ans;         //ans vector is returned
            
        }

        return {};          //if all cases fail...its unreachable
    }
};
