/*
743. Network Delay Time

You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.

We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.

 

Example 1:


Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
Example 2:

Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
Example 3:

Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
 

Constraints:

1 <= k <= n <= 100
1 <= times.length <= 6000
times[i].length == 3
1 <= ui, vi <= n
ui != vi
0 <= wi <= 100
All the pairs (ui, vi) are unique. (i.e., no multiple edges.)
*/

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        unordered_map<int,unordered_map<int,int>> mp;                        //creates adjacency list of nodes with weights
        for(auto v:times)
        {
            mp[v[0]][v[1]]=v[2];
        }
        vector<int> time(n+1,INT_MAX);                                      //stores minimum time for signal to reach that node from kth node
        time[k]=0;                                                          //from k to k,time is 0

        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> pq;    //we implement dijktra's algorithm,to store edges from a node in ascending order via min heap in form of {weight,node}
        pq.push({0,k});                                                      //we push kth node and its time

        while(!pq.empty())
        {
            auto x=pq.top();                                                      //we take out the top node which has least time
            pq.pop();  
            for(auto p:mp[x.second])                  //we iterate through its neighbors and if time of any of neighbors is more than (time of node+weight),we replace the time of neighbor and push the neighbor node and its time onto the heap
            {
                if(time[p.first]>time[x.second]+p.second)
                {
                    time[p.first]=min(time[p.first],time[x.second]+p.second);
                    pq.push({time[p.first],p.first}); 
                }       
            }
        }
        int m=*max_element(time.begin()+1,time.end());      //we find maximum element from 1st node time to nth node time.if INT_MAX,we return -1 as all nodes cant be reached.else return the max element
        if(m==INT_MAX) return -1;
        else return m;
    }
};
