/*
210. Course Schedule II

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
Example 2:

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
Example 3:

Input: numCourses = 1, prerequisites = []
Output: [0]
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= numCourses * (numCourses - 1)
prerequisites[i].length == 2
0 <= ai, bi < numCourses
ai != bi
All the pairs [ai, bi] are distinct.
*/

class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> ans;                                  //to store correct order of course completion if possible
        unordered_map<int,unordered_set<int>> pre,post;    //pre maps a course to its pre-requisites.post maps a pre-requisite to a course
        for(auto v:prerequisites)      //first we create pre and post maps from prerequisites vector
        {
            pre[v[0]].insert(v[1]);
            post[v[1]].insert(v[0]);
        }
        unordered_set<int> completed,visited;    //completed stores the courses completed and visited stores which courses have been dealt with by pushing them in the queue
        queue<int> q;                  //for BFS
        for(int i=0;i<numCourses;i++)    //if a course has no prerequisites,we push them on q as they can be completed easily
        if(pre[i].size()==0)
        {
            q.push(i);
            visited.insert(i);
        }

        while(!q.empty())
        {
            auto x=q.front();                //we pop off front element of queue and mark it a scompleted and put it in ans vector as well
            q.pop();
            completed.insert(x);
            ans.push_back(x);

            for(auto i:post[x])        //then we iterate among those courses which had x as prerequisite and delete x from their dependecy as it has been completed
            {
                pre[i].erase(x);
                if(pre[i].size()==0&&visited.find(i)==visited.end())    //if there is no prerequisite to be done after x has been erase,then it can be added to the queue for completion
                {
                    q.push(i);
                    visited.insert(i);
                }
            }
            
        }
        if(completed.size()==numCourses)      //if we have completed numCourses number of courses,it means all courses have been completed.so we return ans vector
        return ans;

        return {};  //else we return empty vector
    }
};

